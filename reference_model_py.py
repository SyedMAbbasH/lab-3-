# -*- coding: utf-8 -*-
"""reference_model.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bE-mWi2-Tz17uzdY8G6Xo16GfMT7bViM
"""

# Reference model for your systolic_array_top


W3 = 2
W2 = -1
W1 = 3

def systolic_cycle(x_in_left, y_prev_right,
                   x3, x2, x1,
                   Y3, Y2, Y1):
    """
    Simulate one clock cycle of your 3-slice array.

    x3, x2, x1 = current registered X values in slice3,2,1 (left->right)
    Y3, Y2, Y1 = current partial sums in slice3,2,1 (left->right)

    Returns:
        (x3_next, x2_next, x1_next, Y3_next, Y2_next, Y1_next)
    """


    x3_next = x_in_left
    x2_next = x3
    x1_next = x2


    Y3_next = Y2 + x_in_left * W3
    Y2_next = Y1 + x3       * W2
    Y1_next = y_prev_right + x2 * W1

    return x3_next, x2_next, x1_next, Y3_next, Y2_next, Y1_next


def run_case(name, X_seq, Yprev_seq):
    print(f"\n=== {name} ===")
    print("cycle |  x_in | y_prev_right |  results_left  y_slice2  y_slice1")

    # Initial pipeline/register state (after reset)
    x3 = x2 = x1 = 0
    Y3 = Y2 = Y1 = 0

    for i, (x_in, ypr) in enumerate(zip(X_seq, Yprev_seq)):
        x3, x2, x1, Y3, Y2, Y1 = systolic_cycle(x_in, ypr, x3, x2, x1, Y3, Y2, Y1)

        # results_left = Y3, y_slice2_out = Y2, y_slice1_out = Y1
        print(f"{i:5d} | {x_in:5d} | {ypr:12d} | {Y3:12d} {Y2:8d} {Y1:8d}")

    return



# Case 1

X_case1     = [5, -2, 1, 0, 0, 0, 0, 0]
Yprev_case1 = [0,  0, 0, 0, 0, 0, 0, 0]

# -----------------------
# Case 2

X_case2     = [0,  3, -1, 4, 0, 0, 0, 0]
Yprev_case2 = [10, 10, -5, 7, 0, 0, 0, 0]

# -----------------------
# Case 3

X_case3     = [3, -1, 6, -2, 9, -3, 0, 0]
Yprev_case3 = [0,  0, 0,  0, 0,  0, 0, 0]

if __name__ == "__main__":
    run_case("Case 1: y_prev_right = 0", X_case1, Yprev_case1)
    run_case("Case 2: non-zero y_prev_right", X_case2, Yprev_case2)
    run_case("Case 3: interleaved streams", X_case3, Yprev_case3)